#!/usr/bin/env node
'use strict';
var commander = require('commander');
var pkg       = require('../package.json');
var rocker_bin = require('../lib/index.js');
var path = require('path')
const fs = require('fs')
const { Console } = require('console');

commander.version(pkg.version)
  .option('-v --version', 'print rocker version')
  .option('-l --log [path]', 'specify log file which gathers both stdout and stderr')
  .option('-n --name <name>', 'set a name for the process in the process list')
  .option('-i --instances <number>', 'launch [number] instances (for networked app)(load balanced)')
  .usage('[cmd] app');

commander.command('start [name|file|ecosystem|id...]')
  // .option('--watch', 'Watch folder for changes')
  .option('--node-version [major]', 'with --container, set a specific major Node.js version')
  .description('start and daemonize an app')
  .action(function(cmd, opts) {
    let exec = cmd && cmd[0]
    cmd = patchCommanderArg(cmd);
    let count = commander.instances || null
    let logPath = commander.log || './'
    logPath = path.resolve(process.cwd(), logPath)
    setLogger(logPath)

    var rocker = new rocker_bin({ count, exec })
    process.on('uncaughtException:', err => {
      console.log('uncaughtException', err)
      rocker.onReload()
    });
    process.on('unhandledRejection', (reason, p) => {
      console.log('unhandledRejection:', p, '原因：', reason)
      rocker.onReload()
    })
  })

commander.parse(process.argv)
var _arr = process.argv.indexOf('--') > -1 ? process.argv.slice(0, process.argv.indexOf('--')) : process.argv;
console.log('_arr', _arr);

function patchCommanderArg(cmd) {
  var argsIndex;
  if ((argsIndex = commander.rawArgs.indexOf('--')) >= 0) {
    var optargs = commander.rawArgs.slice(argsIndex + 1);
    cmd = cmd.slice(0, cmd.indexOf(optargs[0]));
  }
  return cmd;
}

function setLogger(logPath) {
  const _console = {
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error,
    time: console.time,
    timeEnd: console.timeEnd,
    trace: console.trace,
  }
  const output = fs.createWriteStream(path.resolve(process.cwd(), logPath, './stdout.log'))
  const errorOutput = fs.createWriteStream(path.resolve(process.cwd(), logPath, './stderr.log'))
  const logger = new Console(output, errorOutput)
  global.console.log = function(...args) {
    _console.log(...args);
    logger.log(...args);
  }
  global.console.info = function(...args) {
    _console.info(...args);
    logger.info(...args);
  }
  global.console.warn = function(...args) {
    _console.warn(...args);
    logger.warn(...args);
  }
  global.console.error = function(...args) {
    _console.error(...args);
    logger.error(...args);
  }
  global.console.time = function(...args) {
    _console.time(...args);
    logger.time(...args);
  }
  global.console.timeEnd = function(...args) {
    _console.timeEnd(...args);
    logger.timeEnd(...args);
  }
  global.console.trace = function(...args) {
    _console.trace(...args);
    logger.trace(...args);
  }
}